#ifndef SHELL_H
#define SHELL_H

/* compliation */
/* gcc -Wall -Werror -Wextra -pedantic -std=gnu89 *.c -o hsh */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

/* libraries 4 waitpid */

#include <sys/types.h>
#include <sys/wait.h>

/* library 4 stat */
#include <sys/stat.h>

/* delimeter */

/* include global variables */

extern char **environ;

/* handle inputLine */

char *readLine(void);
char **splitLine(char *Line);
int executeCommand(char **arguments, char **argv, int index);
char *getEnv(char *key);
char *getFullPath(char *Command);

int checkBuiltIn(char **arguments);

/* handle built in */

void handleBuiltIn(char **arguments, char **argv, int status, int index);
void handleExit(char **arguments, char **argv, int status, int index);

void handleEnv(char **environ);

/* features functions */

void free1DArrayMemory(char *array);
void free2DArrayMemory(char **array);

/* string */

int _strlen(char *s);
char *_strcpy(char *dest, char *src);
int _strcmp(char *s1, char *s2);
char *_strcat(char *dest, const char *src);
char *_strdup(char *str);

void _strrev(char *string, int len);
char *int2str(int n);

void handleError(char *progName, char *Command, int index);

/* gcc -g -o hsh *.c shell.h */
/* gdb ./hsh */

/* cp hsh /mnt/f/alx/simpleshell/automated_checker/automated_checker */

#endif

------------------------------------------------

#include "shell.h"

/**
 * main - entry point to the simple shell alx project
 * @argc: arguments count
 * @argv: arguments vector
 * Return: 0 on success
 */

int main(int argc, char **argv)
{
	char *inputline = NULL;
	char **arguments = NULL;
	int status = 0;
	int errIndeX = 0;

	int checkCommand = 0;

	(void)argc;

	while (1)
	{
		if (isatty(STDIN_FILENO))
			write(STDOUT_FILENO, "$ ", 2);

		inputline = readLine();

		if (inputline == NULL)
		{
			if (isatty(STDIN_FILENO))
				write(STDOUT_FILENO, "\n", 1);
			return (status);
		}
		errIndeX++;

		arguments = splitLine(inputline);
		if (arguments == NULL)
			continue;

		checkCommand = checkBuiltIn(arguments);

		if (checkCommand == 1)
			handleBuiltIn(arguments, argv, status, errIndeX);
		else
			status = executeCommand(arguments, argv, errIndeX);
	}
}


------------------------------------------------------

#include "shell.h"

/**
 * readLine - a function that reads user's inputs from stdin or stream
 *
 *
 * Return: line on success - NULL on failure
 */

char *readLine()
{
	FILE *stream;
	char *line = NULL;
	size_t len;
	ssize_t nread;

	stream = stdin;

	nread = getline(&line, &len, stream);
	if (nread == -1)
	{
		free1DArrayMemory(line);
		return (NULL);
	}

	return (line);
}


-------------------------------------------------------

#include "shell.h"

/**
 * splitLine - a function that split a line into tokens
 * @line: line
 *
 * Return: tokens on success
 */

char **splitLine(char *line)
{
	char *delim = " \t\n";
	char *token = NULL, **arguments = NULL;
	char *tempLine = NULL;
	unsigned int i = 0;

	if (line == NULL)
		return (NULL);

	tempLine = _strdup(line);
	if (tempLine == NULL)
	{
		free1DArrayMemory(tempLine), free1DArrayMemory(line);
		return (NULL);
	}
	token = strtok(tempLine, delim);
	if (token == NULL)
	{
		free1DArrayMemory(tempLine), free1DArrayMemory(line);
		return (NULL);
	}
	arguments = malloc(sizeof(char *) * 256);
	if (arguments == NULL)
	{
		free1DArrayMemory(tempLine), free1DArrayMemory(line);
		return (NULL);
	}
	while (token)
	{
		arguments[i++] = _strdup(token);
		token = strtok(NULL, delim);
	}
	arguments[i] = NULL;

	free1DArrayMemory(tempLine), free1DArrayMemory(line);
	return (arguments);
}


---------------------------------------------------


#include "shell.h"

/**
 * executeArgs - a function that excute user's input line
 * @arguments: line tokens
 * @argv: arguments vector
 * @errIndex: error index number
 * Return: status
 */

int executeArgs(char **arguments, char **argv, int errIndex)
{
	pid_t forking;
	int status;
	char *fullCommandPath = NULL;
	(void)argv;

	fullCommandPath = getFullPath(arguments[0]);
	if (fullCommandPath == NULL)
	{
		handleError(argv[0], arguments[0], errIndex);
		free2DArrayMemory(arguments);
		exit(127);
	}

	forking = fork();
	if (forking == 0)
	{
		if (execve(fullCommandPath, arguments, environ) == -1)
		{
			handleError(argv[0], arguments[0], errIndex);
			free2DArrayMemory(arguments);
			free1DArrayMemory(fullCommandPath);
			exit(127);
		}
	}
	else if (forking == -1)
	{
		handleError(argv[0], arguments[0], errIndex);
		free2DArrayMemory(arguments);
		free1DArrayMemory(fullCommandPath);
	}
	else
	{
		waitpid(forking, &status, 0);
		free2DArrayMemory(arguments);
		free1DArrayMemory(fullCommandPath);
	}

	return (WEXITSTATUS(status));
}


----------------------------------------------------


#include "shell.h"

/**
 * getEnv - a fuction that return the environ variable value of PATH environ
 * @key: variable key
 * Return: envPathValue on success
 */

char *getEnv(char *key)
{
	unsigned int i = 0;
	char *varKey = NULL;
	char *varValue = NULL;
	char *tempEnviron = NULL;
	char *envPathValue = NULL;

	for (i = 0; environ[i]; i++)
	{
		tempEnviron = _strdup(environ[i]);

		varKey = strtok(tempEnviron, "=");
		if (_strcmp(varKey, key) == 0)
		{
			varValue = strtok(NULL, "\n");
			envPathValue = _strdup(varValue);
			free1DArrayMemory(tempEnviron);
			return (envPathValue);
		}
		free1DArrayMemory(tempEnviron);
	}

	return (NULL);
}


----------------------------------------------------


#include "shell.h"

/**
 * getFullPath - a fuction that return the fullPath for a given Command
 * @Command: input command
 * Return: fullPath on success
 */

char *getFullPath(char *Command)
{
	struct stat st;
	char *envPathValue = NULL, *path = NULL;
	char *fullCommandPath = NULL;
	char *key = "PATH";

	if (Command == NULL)
		return (NULL);

	if (stat(Command, &st) == 0)
		return (_strdup(Command));

	envPathValue = getEnv(key);
	if (envPathValue == NULL)
		return (NULL);
	path = strtok(envPathValue, ":");
	while (path)
	{
		fullCommandPath = malloc(sizeof(char) * 256);
		if (fullCommandPath == NULL)
		{
			free1DArrayMemory(envPathValue);
			return (NULL);
		}
		_strcpy(fullCommandPath, path);
		_strcat(fullCommandPath, "/");
		_strcat(fullCommandPath, Command);
		if (stat(fullCommandPath, &st) == 0)
		{
			free1DArrayMemory(envPathValue);
			return (fullCommandPath);
		}
		free1DArrayMemory(fullCommandPath);
		path = strtok(NULL, ":");
	}

	free1DArrayMemory(envPathValue);
	return (NULL);
}


------------------------------------------------


#include "shell.h"

/**
 * handleError - a function that handle errors
 * @progName: program name
 * @Command: command name
 * @index: error index number
 * Return: void
 */

void handleError(char *progName, char *Command, int index)
{
	char *idx;
	char message[] = "not found";

	idx = int2str(index);

	write(STDERR_FILENO, progName, _strlen(progName));
	write(STDERR_FILENO, ": ", 2);
	write(STDERR_FILENO, idx, _strlen(idx));
	write(STDERR_FILENO, ": ", 2);
	write(STDERR_FILENO, Command, _strlen(Command));
	write(STDERR_FILENO, ": ", 2);
	write(STDERR_FILENO, message, _strlen(message));
	write(STDERR_FILENO, "\n", 1);

	free1DArrayMemory(idx);
}


------------------------------------------------


#include "shell.h"

/**
 * checkBuiltIn - a function that checkCommand is BuiltIn Command or not
 * @arguments: arguments
 * Return: 0 on success
 */
int checkBuiltIn(char **arguments)
{
	unsigned int i = 0;
	char *builtIn[] = {"exit", "env", NULL};

	for (i = 0; builtIn[i]; i++)
	{
		if (_strcmp(arguments[0], builtIn[i]) == 0)
			return (1);
	}

	return (0);
}

/**
 * handleBuiltIn - a function that handle shell BuiltIn Commands
 * @arguments: arguments
 * @argv: arguments vector
 * @status: execution statues
 * @errIndeX: error number
 * Return: void
 */

void handleBuiltIn(char **arguments, char **argv, int status, int errIndeX)
{

	if (_strcmp(arguments[0], "exit") == 0)
		handleExit(arguments, argv, status, errIndeX);

	else if (_strcmp(arguments[0], "env") == 0)
		handleEnv(environ);

	else
		handleError(argv[0], arguments[0], errIndeX);
}

/**
 * handleExit - a function that handle shell exit command
 * @arguments: arguments
 * @argv: arguments vector
 * @status: execution statues
 * @errIndeX: error number
 * Return: void
 */

void handleExit(char **arguments, char **argv, int status, int errIndeX)
{
	(void)argv;
	(void)errIndeX;

	free2DArrayMemory(arguments);
	exit(status);
}

/**
 * handleEnv - a function that handle shell env command
 * @environ: environ
 * Return: void
 */

void handleEnv(char **environ)
{
	unsigned int i = 0;

	for (i = 0; environ[i]; i++)
	{
		write(STDOUT_FILENO, environ[i], _strlen(environ[i]));
		write(STDOUT_FILENO, "\n", 1);
	}
}


--------------------------------------------------


#include "shell.h"

/**
 * free1DArrayMemory - a function that free 1D Array Memory
 * @array: 1D Array
 * Return: void
 */

void free1DArrayMemory(char *array)
{
	if (array)
	{
		free(array), array = NULL;
	}
}

/**
 * free2DArrayMemory - a function that free 2D Array Memory
 * @array: 2D Array
 * Return: void
 */

void free2DArrayMemory(char **array)
{
	if (array)
	{
		int i = 0;

		for (i = 0; array[i]; i++)
		{
			free(array[i]), array[i] = NULL;
		}

		free(array), array = NULL;
	}
}


------------------------------------------------


#include "shell.h"

/**
 * free1DArrayMemory - a function that free 1D Array Memory
 * @array: 1D Array
 * Return: void
 */

void free1DArrayMemory(char *array)
{
	if (array)
	{
		free(array), array = NULL;
	}
}

/**
 * free2DArrayMemory - a function that free 2D Array Memory
 * @array: 2D Array
 * Return: void
 */

void free2DArrayMemory(char **array)
{
	if (array)
	{
		int i = 0;

		for (i = 0; array[i]; i++)
		{
			free(array[i]), array[i] = NULL;
		}

		free(array), array = NULL;
	}
}


------------------------------------------------------


#include "shell.h"

/**
 * int2str - a function that convert integer to string
 * @n: integer number
 * Return: string
 */

char *int2str(int n)
{
	int i = 0;
	char buffer[32];

	if (n == 0)
		buffer[i++] = '0';
	else
	{
		while (n > 0)
		{
			buffer[i++] = (n % 10) + '0';
			n /= 10;
		}
	}
	buffer[i] = '\0';
	_strrev(buffer, i);

	return (_strdup(buffer));
}

/**
 * _strrev - a function that reverse a string
 * @string: string 2 reverse
 * @len: string lenght
 * Return: void
 */

void _strrev(char *string, int len)
{
	char temp;
	int start = 0;
	int end = len - 1;

	while (start < end)
	{
		temp = string[start];
		string[start] = string[end];
		string[end] = temp;
		start++;
		end--;
	}
}
